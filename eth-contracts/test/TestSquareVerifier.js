// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
const SquareVerifier = artifacts.require('SquareVerifier');


contract('SquareVerifier', async () => {

    let contract={};

    // Take from the proof.json generated by Zokrates
    const proofJSON = {
        "proof": {
            "a": ["0x06d97881724399e353b76767a8018980045d12959271171b939bfa200728babd", "0x2c0299b05bedf3d0a41cb79da0427823c0093dde43915588762e88d7decdc7f1"],
            "b": [["0x10487796a19f8ff75ccdb86a1180fbb3c43c55a4929563faac11dcda7518e81a", "0x17ddf68c083cf538bc66467cf456ab88f4bf58874f872f2d6176c8671ff6642a"],
                ["0x2a720415fad5ced4f289d957ba6f79138f41f103368678faefb54816f21c3266", "0x07d48fbbd723a4180397cbea66ddd294f9c91f9919d0f67612371898123eb8a9"]],
            "c": ["0x052c54e54dc82fc5f6968d03d937eeae37ad4d6841bbb792a4d78400900a9949", "0x2f753d066a2c0618f080a7079855ab6faa1b334a910c8a9afc32533aa65b1e48"]
        },
        "inputs": ["0x000000000000000000000000000000000000000000000000000000000001bba1", "0x0000000000000000000000000000000000000000000000000000000000000001"]
    };

    beforeEach(function() {
        return SquareVerifier.new()
            .then(function(instance) {
                contract = instance;
            });
    });


    describe('verifies properly', function () {

        const {proof, inputs} = proofJSON;


        it('should accept a correct proof', async function () {
            // ARRANGE
            let revert = false;
            let result={};

            // ACT
            try {
                result = await contract.verifyTx(proof.a, proof.b, proof.c, inputs);
            } catch (e) {
                revert=true;
                console.log(e);
            }

            // ASSERT
            assert.equal(revert, false, `Should not revert`);
            assert.equal(result.logs[0].event, 'Verified', `Should emit a Verified event`);
        });


        it('should reject an incorrect proof', async function () {
            // ARRANGE
            let revert = false;
            // Taken "a" and replace some leading values with 0s in first element
            const modifiedA = ["0x00000881724399e353b76767a8018980045d12959271171b939bfa200728babd", "0x2c0299b05bedf3d0a41cb79da0427823c0093dde43915588762e88d7decdc7f1"];

            // ACT
            try {
                await contract.verifyTx(modifiedA, proof.b, proof.c, inputs);
            } catch (e) {
                revert=true;
            }

            // ASSERT
            assert.equal(revert, true, `Should revert due to incorrect input`);
        });
    });
});